"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEach = forEach;
exports.reduce = reduce;
exports.map = map;
exports.serie = serie;
exports.some = some;
exports.wrap = wrap;
const q_1 = __importDefault(require("q"));
const immutable_1 = __importDefault(require("immutable"));
// Debugging for long stack traces
if (process.env.DEBUG || process.env.CI) {
    q_1.default.longStackSupport = true;
}
/**
 * Reduce an array to a promise
 *
 * @param {Array|List} arr
 * @param {Function(value, element, index)} iter
 * @param {Array|List} base
 * @return {Promise<Mixed>}
 */
function reduce(arr, iter, base) {
    arr = immutable_1.default.Iterable.isIterable(arr) ? arr : immutable_1.default.List(arr);
    return arr.reduce((prev, elem, key) => {
        return prev.then((val) => {
            return iter(val, elem, key);
        });
    }, (0, q_1.default)(base));
}
/**
 * Iterate over an array using an async iter
 *
 * @param {Array|List} arr
 * @param {Function(value, element, index)}
 * @return {Promise}
 */
function forEach(arr, iter) {
    // @ts-expect-error ts-migrate(2554) FIXME: Expected 3 arguments, but got 2.
    return reduce(arr, (val, el, key) => {
        return iter(el, key);
    });
}
/**
 * Transform an array
 *
 * @param {Array|List} arr
 * @param {Function(value, element, index)}
 * @return {Promise}
 */
function serie(arr, iter, base) {
    return reduce(arr, (before, item, key) => {
        return (0, q_1.default)(iter(item, key)).then((r) => {
            before.push(r);
            return before;
        });
    }, []);
}
/**
 * Iter over an array and return first result (not null)
 *
 * @param {Array|List} arr
 * @param {Function(element, index)}
 * @return {Promise<Mixed>}
 */
function some(arr, iter) {
    arr = immutable_1.default.List(arr);
    return arr.reduce((prev, elem, i) => {
        return prev.then((val) => {
            if (val)
                return val;
            return iter(elem, i);
        });
    }, (0, q_1.default)());
}
/**
 * Map an array using an async (promised) iterator
 *
 * @param {Array|List} arr
 * @param {Function(element, index)}
 * @return {Promise<List>}
 */
function mapAsList(arr, iter) {
    return reduce(arr, (prev, entry, i) => {
        return (0, q_1.default)(iter(entry, i)).then((out) => {
            prev.push(out);
            return prev;
        });
    }, []);
}
/**
 * Map an array or map
 *
 * @param {Array|List|Map|OrderedMap} arr
 * @param {Function(element, key)}
 * @return {Promise<List|Map|OrderedMap>}
 */
function map(arr, iter) {
    if (immutable_1.default.Map.isMap(arr)) {
        let type = "Map";
        if (immutable_1.default.OrderedMap.isOrderedMap(arr)) {
            type = "OrderedMap";
        }
        return mapAsList(arr, (value, key) => {
            return (0, q_1.default)(iter(value, key)).then((result) => {
                return [key, result];
            });
        }).then((result) => {
            return immutable_1.default[type](result);
        });
    }
    else {
        return mapAsList(arr, iter).then((result) => {
            return immutable_1.default.List(result);
        });
    }
}
/**
 * Wrap a function in a promise
 *
 * @param {Function} func
 * @return {Funciton}
 */
function wrap(func) {
    return function () {
        const args = Array.prototype.slice.call(arguments, 0);
        return (0, q_1.default)().then(() => {
            return func.apply(null, args);
        });
    };
}
q_1.default.forEach = forEach;
q_1.default.reduce = reduce;
q_1.default.map = map;
q_1.default.serie = serie;
q_1.default.some = some;
q_1.default.wrap = wrap;
exports.default = q_1.default;
