import { ParserOptions } from "../models/parser";
/**
 Encode a global context into a JS object
 It's the context for page's hook, etc

 @param {Output} output
 @return {Object}
 */
declare function encodeGlobal(output: any): {
    log: any;
    config: {
        values: any;
        get: (key: any, defaultValue: any) => any;
        set: (key: any, value: any) => any;
    };
    summary: {
        walk: (iter: any) => void;
        getArticleByLevel: (level: any) => {
            title: string;
            level: string;
            depth: number;
            anchor: string;
            url: string;
            path: string;
            ref: string;
            articles: any;
        };
        getArticleByPath: (level: any) => {
            title: string;
            level: string;
            depth: number;
            anchor: string;
            url: string;
            path: string;
            ref: string;
            articles: any;
        };
    };
    /**
     Check if the book is a multilingual book

     @return {boolean}
     */
    isMultilingual: () => any;
    /**
     Check if the book is a language book for a multilingual book

     @return {boolean}
     */
    isLanguageBook: () => any;
    /**
     Read a file from the book

     @param {string} fileName
     @return {Promise<Buffer>}
     */
    readFile: (fileName: any) => any;
    /**
     Read a file from the book as a string

     @param {string} fileName
     @return {Promise<String>}
     */
    readFileAsString: (fileName: any) => any;
    /**
     Resolve a file from the book root

     @param {string} fileName
     @return {string}
     */
    resolve: (fileName: any) => string;
    /**
     Resolve a page by it path

     @param {string} filePath
     @return {string}
     */
    getPageByPath: (filePath: any) => import("./encodePage").EncodedPageWithAttributes;
    /**
     Render a block of text (markdown/asciidoc)

     @param {string} type
     @param {string} text
     @param options
     @return {Promise<String>}
     */
    renderBlock: (type: string, text: string, options: ParserOptions) => any;
    /**
     Render an inline text (markdown/asciidoc)

     @param {string} type
     @param {string} text
     @param options
     @return {Promise<String>}
     */
    renderInline: (type: string, text: string, options: ParserOptions) => any;
    template: {
        /**
         Apply a templating block and returns its result

         @param {string} name
         @param {Object} blockData
         @return {Promise|Object}
         */
        applyBlock: (name: any, blockData: any) => any;
    };
    output: {
        /**
         Name of the generator being used
         {string}
         */
        name: any;
        /**
         Return absolute path to the root folder of output
         @return {string}
         */
        root: () => any;
        /**
         Resolve a file from the output root

         @param {string} fileName
         @return {string}
         */
        resolve: (fileName: any) => string;
        /**
         Convert a filepath into an url
         @return {string}
         */
        toURL: (filePath: any) => string;
        /**
         Check that a file exists.

         @param {string} fileName
         @return {Promise}
         */
        hasFile: (fileName: any, content: any) => any;
        /**
         Write a file to the output folder,
         It creates the required folder

         @param {string} fileName
         @param {Buffer} content
         @return {Promise}
         */
        writeFile: (fileName: any, content: any) => any;
        /**
         Copy a file to the output folder
         It creates the required folder.

         @param {string} inputFile
         @param {string} outputFile
         @param {Buffer} content
         @return {Promise}
         */
        copyFile: (inputFile: any, outputFile: any, content: any) => any;
    };
    gitbook: {
        version: any;
    };
    honkit: {
        version: any;
    };
};
export default encodeGlobal;
//# sourceMappingURL=encodeGlobal.d.ts.map